<snippet>
	<description>half... - 求半平面交</description>
	<content><![CDATA[struct Line  // 直线
{
    PDD st, ed;  // 直线上的两个点
}line[N];
int q[N];  // 双端队列

int sign(double x)  // 符号函数
{
    if (fabs(x) < eps) return 0;  // x为0，则返回0
    if (x < 0) return -1;  // x为负数，则返回-1
    return 1;  // x为正数，则返回1
}

int dcmp(double x, double y)  // 比较两数大小
{
    if (fabs(x - y) < eps) return 0;  // x == y, 返回0
    if (x < y) return -1;  // x < y, 返回-1
    return 1;  // x > y, 返回1
}

PDD operator+ (PDD a, PDD b)  // 向量加法
{
    return {a.x + b.x, a.y + b.y};
}

PDD operator-(PDD a, PDD b)  // 向量减法
{
    return {a.x - b.x, a.y - b.y};
}

double operator* (PDD a, PDD b)  // 外积、叉积
{
    return a.x * b.y - a.y * b.x;
}

PDD operator* (PDD a, double t)  // 向量数乘
{
    return {a.x * t, a.y * t};
}

double area(PDD a, PDD b, PDD c)  // 以a, b, c为顶点的有向三角形面积
{
    return (b - a) * (c - a);
}

PDD get_line_intersection(PDD p, PDD v, PDD q, PDD w)  // 求两直线交点：p + vt, q + wt
{
    auto u = p - q;
    auto t = w * u / (v * w);
    return p + v * t;
}

PDD get_line_intersection(Line a, Line b)  // 求两直线交点
{
    return get_line_intersection(a.st, a.ed - a.st, b.st, b.ed - b.st);
}

bool on_right(Line& a, Line& b, Line& c) // bc的交点是否在a的右侧
{
    auto o = get_line_intersection(b, c);
    return sign(area(a.st, a.ed, o)) <= 0;
}

double get_angle(const Line& a)  // 求直线的极角大小
{
    return atan2(a.ed.y - a.st.y, a.ed.x - a.st.x);
}

bool cmp(const Line& a, const Line& b)  // 将所有直线按极角排序
{
    double A = get_angle(a), B = get_angle(b);
    if (!dcmp(A, B)) return area(a.st, a.ed, b.ed) < 0;
    return A < B;
}

void half_plane_intersection()  // 半平面交，交集的边逆时针顺序存于q[]中
{
    sort(line, line + cnt, cmp);
    int hh = 0, tt = -1;
    for (int i = 0; i < cnt; i ++ )
    {
        if (i && !dcmp(get_angle(line[i]), get_angle(line[i - 1]))) continue;
        while (hh + 1 <= tt && on_right(line[i], line[q[tt - 1]], line[q[tt]])) tt -- ;
        while (hh + 1 <= tt && on_right(line[i], line[q[hh]], line[q[hh + 1]])) hh ++ ;
        q[ ++ tt] = i;
    }
    while (hh + 1 <= tt && on_right(line[q[hh]], line[q[tt - 1]], line[q[tt]])) tt -- ;
    while (hh + 1 <= tt && on_right(line[q[tt]], line[q[hh]], line[q[hh + 1]])) hh ++ ;

    q[ ++ tt] = q[hh];
    // 交集的边逆时针顺序存于q[]中

    // TODO: 求出半平面交后，根据题目要求求答案
}
]]></content>
	<tabTrigger>void hal</tabTrigger>
	<scope>(source.c | source.objc | source.c++ | source.objc++) - meta.preprocessor.include - comment - string</scope>
</snippet>
